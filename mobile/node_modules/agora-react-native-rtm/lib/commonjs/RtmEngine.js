"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _types = require("./types");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
const {
  /**
   * @ignore
   */
  AgoraRTM
} = _reactNative.NativeModules;
/**
 * @ignore
 */
const Prefix = AgoraRTM.prefix;
/**
 * @ignore
 */
const RtmClientEvent = new _reactNative.NativeEventEmitter(AgoraRTM);

/**
 * `RtmEngine` is the entry point of the react native agora rtm sdk. You can call the {@link createClient} method of {@link RtmEngine} to create an `RtmEngine` instance.
 * @noInheritDoc
 */
class RtmEngine {
  constructor() {
    _defineProperty(this, "_listeners", new Map());
  }
  /**
   * @deprecated {@link addListener}
   * supports platform: ios, android
   * @events {@link RtmEngineEvents}
   * @param eventName string required
   * @param callback (evt) => {} required
   */
  on(eventName, callback) {
    switch (eventName) {
      case 'tokenExpired':
        this.addListener('TokenExpired', () => {
          callback(undefined);
        });
        break;
      case 'remoteInvitationRefused':
        this.addListener('RemoteInvitationRefused', remoteInvitation => {
          const ret = {
            ...remoteInvitation
          };
          callback(ret);
        });
        break;
      case 'remoteInvitationFailure':
        this.addListener('RemoteInvitationFailure', (remoteInvitation, errorCode) => {
          const ret = {
            ...remoteInvitation,
            code: errorCode
          };
          callback(ret);
        });
        break;
      case 'remoteInvitationCanceled':
        this.addListener('RemoteInvitationCanceled', remoteInvitation => {
          const ret = {
            ...remoteInvitation
          };
          callback(ret);
        });
        break;
      case 'remoteInvitationAccepted':
        this.addListener('RemoteInvitationAccepted', remoteInvitation => {
          const ret = {
            ...remoteInvitation
          };
          callback(ret);
        });
        break;
      case 'messageReceived':
        this.addListener('MessageReceived', (message, peerId) => {
          var _message$serverReceiv;
          const ret = {
            text: message.text,
            ts: (_message$serverReceiv = message.serverReceivedTs) === null || _message$serverReceiv === void 0 ? void 0 : _message$serverReceiv.toString(),
            offline: message.isOfflineMessage,
            peerId
          };
          callback(ret);
        });
        break;
      case 'localInvitationRefused':
        this.addListener('LocalInvitationRefused', localInvitation => {
          const ret = {
            ...localInvitation
          };
          callback(ret);
        });
        break;
      case 'localInvitationReceivedByPeer':
        this.addListener('LocalInvitationReceivedByPeer', localInvitation => {
          const ret = {
            ...localInvitation
          };
          callback(ret);
        });
        break;
      case 'localInvitationFailure':
        this.addListener('LocalInvitationFailure', (localInvitation, errorCode) => {
          const ret = {
            ...localInvitation,
            code: errorCode
          };
          callback(ret);
        });
        break;
      case 'localInvitationCanceled':
        this.addListener('LocalInvitationCanceled', localInvitation => {
          const ret = {
            ...localInvitation
          };
          callback(ret);
        });
        break;
      case 'localInvitationAccepted':
        this.addListener('LocalInvitationAccepted', localInvitation => {
          const ret = {
            ...localInvitation
          };
          callback(ret);
        });
        break;
      case 'error':
        console.warn('deprecated');
        break;
      case 'connectionStateChanged':
        this.addListener('ConnectionStateChanged', (state, reason) => {
          const ret = {
            reason,
            state
          };
          callback(ret);
        });
        break;
      case 'channelMessageReceived':
        this.addListener('ChannelMessageReceived', (message, fromMember) => {
          var _message$serverReceiv2;
          const ret = {
            channelId: fromMember.channelId,
            offline: message.isOfflineMessage,
            text: message.text,
            ts: (_message$serverReceiv2 = message.serverReceivedTs) === null || _message$serverReceiv2 === void 0 ? void 0 : _message$serverReceiv2.toString(),
            uid: fromMember.userId
          };
          callback(ret);
        });
        break;
      case 'channelMemberLeft':
        this.addListener('ChannelMemberLeft', member => {
          const ret = {
            channelId: member.channelId,
            uid: member.userId
          };
          callback(ret);
        });
        break;
      case 'channelMemberJoined':
        this.addListener('ChannelMemberJoined', member => {
          const ret = {
            channelId: member.channelId,
            uid: member.userId
          };
          callback(ret);
        });
        break;
      case 'remoteInvitationReceived':
        this.addListener('RemoteInvitationReceived', remoteInvitation => {
          const ret = {
            ...remoteInvitation
          };
          callback(ret);
        });
        break;
    }
  }

  /**
   * @deprecated {@link removeAllListeners}
   */
  removeEvents() {
    this.removeAllListeners();
  }
  addListener(event, listener) {
    const callback = res => {
      // @ts-ignore
      listener(...res);
    };
    let map = this._listeners.get(event);
    if (map === undefined) {
      map = new Map();
      this._listeners.set(event, map);
    }
    const subscription = RtmClientEvent.addListener(Prefix + event, callback);
    map.set(listener, subscription);
    return subscription;
  }
  removeListener(event, listener) {
    const map = this._listeners.get(event);
    if (map === undefined) return;
    RtmClientEvent.removeSubscription(map.get(listener));
    map.delete(listener);
  }
  removeAllListeners(event) {
    if (event === undefined) {
      this._listeners.forEach((_, key) => {
        RtmClientEvent.removeAllListeners(Prefix + key);
      });
      this._listeners.clear();
      return;
    }
    RtmClientEvent.removeAllListeners(Prefix + event);
    this._listeners.delete(event);
  }

  /**
   * @deprecated {@link release}
   * supports platform: ios, android
   * This method destroy AgoraRTM instance, stop event observing, release all both remote and local invitaitons and channels resources.
   * @return void
   */
  destroyClient() {
    return this.release();
  }
  async release() {
    this.removeAllListeners();
    await AgoraRTM.destroy();
  }

  /**
   * @deprecated {@link loginV2}
   * supports platform: ios, android
   * This method do login with UserInfo
   * @param params {@link UserInfo}
   * ---
   * token | string | optional |
   * uid | string | required |
   * ---
   * @return Promise<void>
   */
  login(params) {
    return this.loginV2(params.uid, params.token);
  }
  loginV2(userId, token) {
    return AgoraRTM.login({
      token,
      userId
    });
  }

  /**
   * supports platform: ios, android
   * This method do logout.
   * @return Promise<void>
   */
  logout() {
    return AgoraRTM.logout();
  }

  /**
   * @deprecated {@link sendMessageToPeerV2}
   * supports platform: ios, android
   * This method do send p2p message with {@link AgoraPeerMessage}
   * @param params AgoraPeerMessage
   * ---
   * peerId | string | required |
   * offline | boolean | requried |
   * text | string | required |
   * ---
   * @return Promise<void>
   */
  sendMessageToPeer(params) {
    return this.sendMessageToPeerV2(params.peerId, new _types.RtmMessage(params.text), {
      enableOfflineMessaging: params.offline
    });
  }
  sendMessageToPeerV2(peerId, message, options) {
    return AgoraRTM.sendMessageToPeer({
      peerId,
      message,
      options
    });
  }

  /**
   * @deprecated {@link queryPeersOnlineStatusV2}
   * supports platform: ios, android
   * This method enables query peer online user by id array.
   * @param ids string array
   * @return Promise<ListPeerStatus> {@link ListPeerStatus}
   * ---
   * items | {@link MemberStatus} |
   * ---
   *
   * MemberStatus
   * ---
   * uid | string | user id|
   * online | boolean | online state|
   * ---
   */
  queryPeersOnlineStatus(ids) {
    return this.queryPeersOnlineStatusV2(ids).then(res => {
      return {
        items: Object.entries(res).map(value => {
          return {
            uid: value[0],
            online: value[1] === _types.PeerOnlineState.ONLINE
          };
        })
      };
    });
  }
  queryPeersOnlineStatusV2(peerIds) {
    return AgoraRTM.queryPeersOnlineStatus({
      peerIds
    });
  }
  subscribePeersOnlineStatus(peerIds) {
    return AgoraRTM.subscribePeersOnlineStatus({
      peerIds
    });
  }
  unsubscribePeersOnlineStatus(peerIds) {
    return AgoraRTM.unsubscribePeersOnlineStatus({
      peerIds
    });
  }
  queryPeersBySubscriptionOption(option) {
    return AgoraRTM.queryPeersBySubscriptionOption({
      option
    });
  }

  /**
   * supports platform: ios, android
   * This method do renewToken when got `tokenExpired` event.
   * @param token string
   * @return Promise<void>
   */
  renewToken(token) {
    return AgoraRTM.renewToken({
      token
    });
  }

  /**
   * @deprecated {@link setLocalUserAttributesV2}
   * supports platform: ios, android
   * This method enables set local user attributes with attributes {@link UserAttribute}
   * @param attributes {@link UserAttribute []}
   * @return Promise<void>
   *
   * UserAttribute
   * ---
   * key | string | required |
   * value | string | required |
   * ---
   */
  setLocalUserAttributes(attributes) {
    return this.setLocalUserAttributesV2(attributes);
  }
  setLocalUserAttributesV2(attributes) {
    return AgoraRTM.setLocalUserAttributes({
      attributes
    });
  }

  /**
   * @deprecated {@link addOrUpdateLocalUserAttributes}
   * supports platform: ios, android
   * This method enables you to replace attribute already exists or add attribute wasn't set for local user attributes;
   * @param attributes {@link UserAttribute []}
   * @return Promise<void>
   */
  replaceLocalUserAttributes(attributes) {
    return this.addOrUpdateLocalUserAttributes(attributes);
  }
  addOrUpdateLocalUserAttributes(attributes) {
    return AgoraRTM.addOrUpdateLocalUserAttributes({
      attributes
    });
  }

  /**
   * @deprecated {@link deleteLocalUserAttributesByKeys}
   * supports platform: ios, android
   * This method enables you to remove exists attribute for local user.
   * @param keys string []
   * @return Promise<void>
   */
  removeLocalUserAttributesByKeys(keys) {
    return this.deleteLocalUserAttributesByKeys(keys);
  }
  deleteLocalUserAttributesByKeys(attributeKeys) {
    return AgoraRTM.deleteLocalUserAttributesByKeys({
      attributeKeys
    });
  }

  /**
   * @deprecated {@link clearLocalUserAttributes}
   * supports platform: ios, android
   * This method enables you to remove all of local user attributes;
   * @return Promise<void>
   */
  removeAllLocalUserAttributes() {
    return this.clearLocalUserAttributes();
  }
  clearLocalUserAttributes() {
    return AgoraRTM.clearLocalUserAttributes();
  }

  /**
   * @deprecated {@link getUserAttributes}
   * supports platform: ios, android
   * This method enables you get user attributes by uid.
   * @param uid string. user id
   * @return Promise<UserProfile> {@link UserProfile}
   */
  getUserAttributesByUid(uid) {
    return this.getUserAttributes(uid).then(res => {
      let ret = {};
      res.forEach(value => {
        ret[value.key] = value.value;
      });
      return {
        uid,
        attributes: ret
      };
    });
  }
  getUserAttributes(userId) {
    return AgoraRTM.getUserAttributes({
      userId
    });
  }
  getUserAttributesByKeys(userId, attributeKeys) {
    return AgoraRTM.getUserAttributesByKeys({
      userId,
      attributeKeys
    });
  }
  setChannelAttributes(channelId, attributes, option) {
    return AgoraRTM.setChannelAttributes({
      channelId,
      attributes,
      option
    });
  }
  addOrUpdateChannelAttributes(channelId, attributes, option) {
    return AgoraRTM.addOrUpdateChannelAttributes({
      channelId,
      attributes,
      option
    });
  }
  deleteChannelAttributesByKeys(channelId, attributeKeys, option) {
    return AgoraRTM.deleteChannelAttributesByKeys({
      channelId,
      attributeKeys,
      option
    });
  }
  clearChannelAttributes(channelId, option) {
    return AgoraRTM.clearChannelAttributes({
      channelId,
      option
    });
  }
  getChannelAttributes(channelId) {
    return AgoraRTM.getChannelAttributes({
      channelId
    });
  }
  getChannelAttributesByKeys(channelId, attributeKeys) {
    return AgoraRTM.getChannelAttributesByKeys({
      channelId,
      attributeKeys
    });
  }
  setParameters(parameters) {
    return AgoraRTM.setParameters({
      parameters
    });
  }

  /**
   * @deprecated {@link setLogFile} {@link setLogFilter} {@link setLogFileSize}
   * set sdk log file
   * @param path string: specified the generated log path
   * @param level {@link LogLevel}: sdk log level (0: "OFF", 0b1111: "INFO", 0b1110: "WARN", 0b1100: "ERROR", 0b1000: "CRITICAL")
   * @param size number: file size in kbytes
   * Note File size settings of less than 512 KB or greater than 10 MB will not take effect.
   * @return Promise<void> This method will return {path: boolean, level: boolean, size: boolean}
   */
  async setSdkLog(path, level, size) {
    await this.setLogFile(path);
    await this.setLogFilter(level);
    await this.setLogFileSize(size);
  }
  setLogFile(filePath) {
    return AgoraRTM.setLogFile({
      filePath
    });
  }
  setLogFilter(filter) {
    return AgoraRTM.setLogFilter({
      filter
    });
  }
  setLogFileSize(fileSizeInKBytes) {
    return AgoraRTM.setLogFileSize({
      fileSizeInKBytes
    });
  }

  /**
   * @deprecated {@link createInstance}
   * supports platform: ios, android
   * This method creates AgoraRTM instance and begin event observing, collect all both remote and local invitations and channels resources.
   * method: createClient
   * @param appId string
   * @return void
   */
  async createClient(appId) {
    return this.createInstance(appId);
  }
  async createInstance(appId) {
    await AgoraRTM.createInstance(appId);
  }

  /**
   * @deprecated
   * get the version of rtm sdk
   * @param callback (version) => {} required
   */
  getSdkVersion(callback) {
    RtmEngine.getSdkVersion().then(res => {
      // @ts-ignore
      callback(res);
    });
  }
  static getSdkVersion() {
    return AgoraRTM.getSdkVersion();
  }

  /**
   * supports platform: ios, android
   * This method do join channel with channelId
   * @param channelId string
   * @return Promise<void>
   */
  joinChannel(channelId) {
    return AgoraRTM.joinChannel({
      channelId
    });
  }

  /**
   * supports platform: ios, android
   * This method do leave channel with channelId
   * @param channelId string
   * @return Promise<void>
   */
  leaveChannel(channelId) {
    return AgoraRTM.leaveChannel({
      channelId
    });
  }

  /**
   * @deprecated {@link sendMessage}
   * supports platform: ios, android
   * This method enables send message by channel id.
   * NOTICE: text bytelength has MAX_SIZE 32kb limit.
   * @param channelId string.
   * @param text string (bytesize shouldn't >= 32kb)
   * @return Promise<void>
   */
  sendMessageByChannelId(channelId, text) {
    return this.sendMessage(channelId, new _types.RtmMessage(text), {});
  }
  sendMessage(channelId, message, options) {
    return AgoraRTM.sendMessage({
      channelId,
      message,
      options
    });
  }

  /**
   * @deprecated {@link getMembers}
   * supports platform: ios, android
   * This method enables you get members by channel id.
   * @param channelId string.
   * @return Promise<Members> {@link Members}}
   *
   * ---
   * members | {@link MemberInfo} |
   * ---
   *
   * MemberInfo
   * ---
   * uid | string | user id|
   * channelId | string | channel id|
   * ---
   */
  getChannelMembersBychannelId(channelId) {
    return this.getMembers(channelId).then(res => {
      return {
        members: res.map(value => {
          return {
            uid: value.userId,
            channelId
          };
        })
      };
    });
  }
  getMembers(channelId) {
    return AgoraRTM.getMembers({
      channelId
    });
  }
  releaseChannel(channelId) {
    return AgoraRTM.releaseChannel({
      channelId
    });
  }
  createLocalInvitation(calleeId, content, channelId) {
    return AgoraRTM.createLocalInvitation({
      calleeId,
      content,
      channelId
    });
  }

  /**
   * @deprecated {@link sendLocalInvitationV2}
   * supports platform: ios, android
   * This method enables send local invitation with invitationProps.
   * NOTICE: content bytelength has MAX_SIZE 32kb limit.
   * @param invitationProps {@link LocalInvitationProps}
   *
   * LocalInvitationProps
   * ---
   * uid | string | required |
   * channelId | string | required |
   * content | string | optional | 32kb limit |
   * ---
   *
   * @return Promise<void>
   */
  async sendLocalInvitation(invitationProps) {
    return this.sendLocalInvitationV2(await this.createLocalInvitation(invitationProps.uid, invitationProps.content, invitationProps.channelId));
  }
  sendLocalInvitationV2(localInvitation) {
    return AgoraRTM.sendLocalInvitation({
      localInvitation
    });
  }

  /**
   * @deprecated {@link acceptRemoteInvitationV2}
   * supports platform: ios, android
   * This method enables accept remote invitation with RemoteInvitationProps.
   * NOTICE: content bytelength has MAX_SIZE 32kb limit.
   * @param remoteInvitationProps {@link RemoteInvitationProps}
   *
   * RemoteInvitationProps
   * ---
   * uid | string | required |
   * channelId | string | required |
   * response | string | optional | 32kb limit |
   * ---
   *
   * @return Promise<void>
   */
  acceptRemoteInvitation(remoteInvitationProps) {
    return this.acceptRemoteInvitationV2({
      callerId: remoteInvitationProps.uid,
      response: remoteInvitationProps.response,
      channelId: remoteInvitationProps.channelId,
      hash: 0
    });
  }
  acceptRemoteInvitationV2(remoteInvitation) {
    return AgoraRTM.acceptRemoteInvitation({
      remoteInvitation
    });
  }

  /**
   * @deprecated {@link refuseRemoteInvitationV2}
   * supports platform: ios, android
   * This method enables refuse remote invitation with RemoteInvitationProps.
   * NOTICE: content bytelength has MAX_SIZE 32kb limit.
   * @param remoteInvitationProps {@link RemoteInvitationProps}
   *
   * RemoteInvitationProps
   * ---
   * uid | string | required |
   * channelId | string | required |
   * response | string | optional | 32kb limit |
   * ---
   *
   * @return Promise<void>
   */
  refuseRemoteInvitation(remoteInvitationProps) {
    return this.refuseRemoteInvitationV2({
      callerId: remoteInvitationProps.uid,
      response: remoteInvitationProps.response,
      channelId: remoteInvitationProps.channelId,
      hash: 0
    });
  }
  refuseRemoteInvitationV2(remoteInvitation) {
    return AgoraRTM.refuseRemoteInvitation({
      remoteInvitation
    });
  }

  /**
   * @deprecated {@link cancelLocalInvitationV2}
   * supports platform: ios, android
   * This method enables cancel local invitation with invitationProps.
   * NOTICE: content bytelength has MAX_SIZE 32kb limit.
   * @param invitationProps {@link LocalInvitationProps}
   *
   * LocalInvitationProps
   * ---
   * uid | string | required |
   * channelId | string | required |
   * content | string | optional | 32kb limit |
   * ---
   *
   * @return Promies<any>
   */
  cancelLocalInvitation(invitationProps) {
    return this.cancelLocalInvitationV2({
      calleeId: invitationProps.uid,
      content: invitationProps.content,
      channelId: invitationProps.channelId,
      hash: 0
    });
  }
  cancelLocalInvitationV2(localInvitation) {
    return AgoraRTM.cancelLocalInvitation({
      localInvitation
    });
  }
}
exports.default = RtmEngine;
//# sourceMappingURL=RtmEngine.js.map